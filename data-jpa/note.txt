스프링 데이터 JPA 구현체 분석

jpa 내부 기능을 가지고 활용합니다.
+ 특정 쿼리에 대한 문자를 가지고 있습니다.

컴포넌트 스캔 대상

트랜잭션 리드온리 true로 되어있는데
모든 data jpa 트랜잭션이 기본이 있기 때문에 트랜잭션을 시작합니다.
모든 데이터 변경은 트랜잭션 내에서 동작해야하는데 스프링 data jpa는 기본적으로 트랜잭션이 있다.

read only를 하면 JPA에서 flush()를 제외합니다.
15.4.2 read only entity

다시 영속성 상태를 넣을때 머지를 사용한다.

persist하기전에 PK에 값이 있으면 persist가 아니라 merge가 동작합니다.
식별자에 값으있으니까 db에  merger가 동작합니다

식별자를 넣어줘야할때 Persistable<ID type>이면 isNew인지 아닌지 오버라이딩한다.

엔티티 어데팅은 baseEntity에 많이 넣는다
createDate를 활용한다.

명세


프로젝션
+ 도움이 될 때 있다
디비에서 엔티티를 조회하고 싶을 때
회원의 이름만 가져오고 싶을때 사용하는걸 프로젝션이라고 합니다.
data jpa 프록시를 가지고 가짜를 만들어낸다.
실제구현체는 스프링 데이터 jpa가 만든다.
이름 쿼리랑 같이 사용할 수 있다.

Open Projection = 컬럼을 다 들고옴
Close Projection = 칼럼중 필요한 것만 가져옴

최적화로 가져올때 사용한다.

디버그로 확인해보기

중첩구조는 두번째까지 최적화가 안된다. 루트는 정확한데 중첩이하는 모든 정보를 읽습니다.

복잡한 쿼리는 DTO를 쿼리만

네이티브 가급적 사용하지 않는게 좋다
엔티티로 받을려면 멤버 데이터를 다찍어야합니다.
반환 타입이 지정이 안된다.

DTO를 편하게 만들고 싶은데 네이티브 쿼리 동적 쿼리가 아닐경우에 쓸만하다.
이름은 아무거나 작성해도 된다.
네이티브이지만 페이징이되지만 한계가 잇다.

페이징시 카운트 쿼리를 별도로 작성해야한다.

반환타입으로 OBJECT , TUPLE은 지저분해서 잘 안쓴다.

