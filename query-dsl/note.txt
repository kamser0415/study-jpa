중급문법
튜플은 repository 에서 service단으로 넘어가는건 위험합니다.
순환 참조가 발생하고 queryDsl에 너무 의존적이게 됩니다.
서비스에서 queryDASL에 의존없이 해야한다.

QueryDSL은 DTO로 반환할때 리플렉션을 사용하므로 디폴트 생성자가 필요합니다.
bean은 디폴트 생성자를 기준으로 setter로 넣는다
fields는 필드에 그냥 넣는다. 리플렉션으로 넣는다
생성자 접근 방법 타입이 일치해야합니다.

member.username -> name
프로퍼티명, 필드명이 일치해야합니다. 그런데 dto에 이름이 다를 경우에는 값을 넣지 않습니다.
.as("name") 으로 별칭을 줘야합니다.

별칭 주는 방법중 하나가 ExpressionUtils가 필요합니다.

생성자는 타입?을 보고 들어온다
생성자도 디폴트 생성자가 필요한가

궁극의 프로젝션 @QueryProjection
장점도 좋지만 단점도 있기에 상황을 보고 사용합니다.

@Query프로젝션을 Q파일로 생성이 된다.
컴파일 시점에 타입을 잡아준다..왐마 이게 머시당가

나머지는 런타임 오류가 발생한다. 쿼리를 실행할때 확인한다.
컴파일 오류를 잡을 수 있다.
생성자호출도 가능하다.
타입 체크도 되고 안전한데
단점이
1. 큐파일을 무조건 생성해야한다.
2. DTO가 쿼리 DSL을 오염이 된다.

필드나 빈, 생성자를 사용하는 방법도 있지만

동적쿼리는 Boolean 빌더를 사용할 수 있습니다.
장단점에 따라 나누어 사용합니다.

필수 조건을 넣을 수 있고 조건에 따라 따라 bulilder로 추가할 수있다.

** 실무에서 사용하는 방법 **
public void dynamic
where 은 null 조건을 무시합니다.
재사용이 가능하다.
메소드를 뽑을 수 있으니까 가독성이 좋아진다.
여러 쿼리에서조합해서 사용이 가능합니다.

queryDsl 선택사항
1. Bean으로 QueryFactory를 만들어서 주입받기
    ㄴ 테스토크두 불편
2. 생성자 만들때 new QueryFactory(em)으로 받기
    ㄴ 테스트코드가 간편
